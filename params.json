{"name":"xMan","tagline":"一个通用的跨域解决方案(a general cross domain solution)","body":"xMan\r\n============\r\n\r\n## xMan中文文档\r\n*一个通用的跨域解决方案*\r\n\r\n`xMan`是一个高效的,轻量,易用(整个类库加上扩展方法一共只有10个API),兼容性很强的的跨域帮助库.支持ie6+以上以及所有主流的高级浏览器,提供get和post方法两种跨域方式.<br>\r\n使用`xMan`可以让你的代码实现无缝跨域逻辑的实现.`xMan`竭尽所能的提供各种方法并尽力精简了以下的跨域方法,以便可以让开发者更好的进行跨域操作.\r\n\r\n你可以在遵守 MIT Licence 的前提下随意使用并分发它。`xMan` 代码完全开源并托管在 Github 上。\r\n\r\n### xMan的引入\r\n```html\r\n\r\n  <script type=\"text/javascript\" src=\"./XMan.js\"></script>\r\n    \r\n```\r\n### xMan如何向外暴露(兼容AMD和CMD)\r\n\r\nxMan在生成是先行检测并依附于全局环境中的`exports`和`module`,如果没有的该属性则再次检索依附于`define`和`define.amd`,如果上述两种情况都不存在便依附于`window`.依顺序逐个依附.\r\n\r\n```js\r\n\r\n// 以下为判断逻辑。需要更改的话，请下载之后在此处修改依附逻辑。\r\n  if (\"object\" == typeof exports && \"undefined\" != typeof module) {\r\n      module.exports = entrance();\r\n  } else if (\"function\" == typeof define && define.amd) {\r\n      define([], entrance());\r\n  } else {\r\n      var platform;\r\n      if (\"undefined\" != typeof window) {\r\n          platform = window\r\n      } else {\r\n           \"undefined\" != typeof global ? platform = global : \"undefined\" != typeof self && (platform = self)\r\n      }\r\n       platform.x = entrance()\r\n  }\r\n\r\n```\r\n\r\n### xMan如何使用\r\n\r\n该类库提供的方法皆为异步方法.使用时可直接用x.方法名(parma[...]).使用该方法.如下:\r\n\r\n```js\r\n\r\n  // 本事例仅做演示.\r\n    \r\n  x.jsonp('http://localhost:3000/jsonp', {type: 'jsonp'}, 'cb', function (data) {\r\n      console.log('[LOG] type:jsonp,data: ' + JSON.stringify(data));\r\n  });\r\n\r\n  x.crossDomain('post', 'http://localhost:3000/cors', {type: 'cors'}, function (data) {\r\n      console.log('[LOG] type:cors,data: ' + JSON.stringify(data));\r\n  });\r\n\r\n  x.formRequest('post', 'http://localhost:3000/form', {type: 'form'}, function (data) {\r\n      console.log('[LOG] type:form,data: ' + JSON.stringify(data));\r\n  });\r\n\r\n  var outer = x.frame(window.frames[0]);\r\n    \r\n  outer.on('triggerOuter', function (data) {\r\n      console.log('[LOG triggerOuter] type:frames,data: ' + JSON.stringify(data))\r\n  });\r\n    \r\n  outer.on('Message', function (data) {\r\n      console.log('[LOG Message Outer] type:frames,data: ' + JSON.stringify(data))\r\n  });\r\n    \r\n  outer.emit('triggerInner', {from: 'outer'});\r\n    \r\n  outer.send('this msg from outer');\r\n    \r\n```\r\n\r\n### xMan都有哪些方法\r\n*xMan提供4种请求类型的方法，其中包括`jsonp`、`corssDoamin`、`formrequest`以及`frame`。其中前三种是用于前端与后端进行跨域交互时使用。最后一种frame则是在不同域名的frame窗口之间交互时使用，与服务器不做任何交互，仅仅只是前端不同域名的iframe之间使用。*\r\n\r\n#### 1) jsonp(url, data, jsonpName, callback);\r\n此方法提供是jsonp功能.\r\n\r\n`参数列表:`\r\n>+ @param url         {string} 请求路径\r\n>+ @param data        {string | object} 发送数据\r\n>+ @param jsonpName   {string} 回调函数名称\r\n>+ @param callback    {function} 回调函数\r\n  \r\n`示例用法:`\r\n\r\n```js\r\n\r\n x.jsonp('http://localhost:3000/jsonp', {type: 'jsonp'}, 'cb', function (data) {\r\n     console.log('[LOG] type:jsonp,data: ' + JSON.stringify(data));\r\n });\r\n    \r\n```\r\n\r\n`注意:`<br/>\r\n1: 此方法只能为`GET`方法.<br/>\r\n2: 此方法请求数据有大小限制.(chrome为8k,firefox为7k,ie为2k)<br/>\r\n3: 此方法的兼容性为IE6+以及所有主流浏览器.<br/>\r\n\r\n#### 2) crossDomain(type, url, data, callback, settings);\r\n此方法提供的是跨域资源共享功能(切记:此方法需要server端紧密配合).\r\n\r\n`参数列表:`\r\n>+ @param type         {string} 跨域方法,可以使用两种(GET | POST)\r\n>+ @param url        {string} 请求路径\r\n>+ @param data      {string | string} 发送数据\r\n>+ @param callback    {function} 回调函数\r\n>+ @param settings    {object | undefined} 配置参数列表\r\n\r\n*`settings`是配置参数列表,此列表提供了两个参数[withCredentials]和[headers].其中[withCredentials]为boolean类型,true为携带用户cookie,false(默认)为不携带用户cookie.[headers]为object类型,\r\n主要用于用户自定义头信息.这两个参数都必须服务器允许才可使用,否则会触发`安全错误`.*\r\n\r\n`示例用法:`\r\n\r\n```js\r\n\r\n // 前端代码\r\n // 服务器制定头信息为 myself:byMyself\r\n x.crossDomain('post', 'http://localhost:3000/cors', {type: 'cors'}, function (data) {\r\n      console.log('[LOG] type:cors,data: ' + JSON.stringify(data));\r\n },{withCredentials:true,headers{'myself':'byMyself'}});\r\n \r\n // server代码(仅以nodejs为例)\r\n // 设置允许传输cookie和允许前端自定义指定头信息\r\n  response.writeHead(200, {'Access-Control-Allow-Origin': 'http://localhost:63342',// \r\n    'Access-Control-Allow-Credentials': true,\r\n    'Access-Control-Allow-Headers': 'myself'\r\n  :});\r\n \r\n    \r\n```\r\n\r\n`注意:`<br/>\r\n1: 此方法可使用`GET`或`POST`方法.<br/>\r\n2: 此方法跨域携带cookie和使用自定义头信息必须服务器端配置响应的响应头信息.详情请见:http://www.w3.org/TR/cors<br/>\r\n3: 此方法的兼容性为IE8+以及所有主流浏览器.<br/>\r\n\r\n#### 3) formRequest(type, url, data, callback, enctype);\r\n此方法提供的是基本跨域传输功能(切记:此方法需要server端紧密配合).\r\n\r\n`参数列表:`\r\n>+ @param type         {string} 跨域方法,可以使用两种(GET | POST)\r\n>+ @param url        {string} 请求路径\r\n>+ @param data      {string | string} 发送数据\r\n>+ @param callback    {function} 回调函数\r\n>+ @param enctype    {string} 编码格式\r\n\r\n*`enctype`提供3种选择:<br/>\r\n 1:  [application/x-www-form-urlencoded] 在发送前编码所有字符（默认）;<br/>\r\n 2:  [multipart/form-data] 不对字符编码; <br/>\r\n 3:  [text/plain] 空格转换为 \"+\" 加号，但不对特殊字符编码;*\r\n\r\n`示例用法:`\r\n\r\n```js\r\n\r\n // 前端代码\r\n  x.formRequest('post', 'http://localhost:3000/form', {type: 'form'}, function (data) {\r\n       console.log('[LOG] type:form,data: ' + JSON.stringify(data));\r\n  },'application/x-www-form-urlencoded');\r\n \r\n // server代码(仅以nodejs为例)\r\n  var content = 'server数据' \r\n  var header = {\r\n       'content-type': 'text/html',\r\n       'set-cookie': cookie\r\n  };\r\n  response.writeHead(200, header);\r\n  response.end('<html><head><script>window.name=' \r\n  + JSON.stringify(content) \r\n  + ';location.href=\"about:blank\";</script></head><body></body></html>');\r\n \r\n```\r\n\r\n`注意:`<br/>\r\n1: 此方法可使用`GET`或`POST`方法.<br/>\r\n2: 此方法可以默认为携带cookie<br/>\r\n3: 此方法的兼容性为IE6+以及所有主流浏览器.<br/>\r\n\r\n#### 4) frame(targetWindow);\r\n跨iframe交互使用，此方法返回的是一个frameHandle对象\r\n\r\n`参数列表:`\r\n>+ @param targetWindow   {window}  目标窗口对象\r\n\r\n`示例用法:`\r\n\r\n```js\r\n\r\n // 外部窗口代码，假设外部窗口的URI为 http://localhost:63342\r\n  var outer = x.frame(window.frames[0]);\r\n  outer.on('triggerOuter', function (data) {\r\n      console.log('[LOG triggerOuter] type:frames,data: ' + JSON.stringify(data))\r\n  });\r\n  //⚠注意：Message事件为内置事件，接受对方通过send方法发过来的消息对象必须通过注册该事件才可收到。\r\n  outer.on('Message', function (data) {\r\n      console.log('[LOG Message Outer] type:frames,data: ' + JSON.stringify(data))\r\n  });\r\n  setTimeout(function () {\r\n      outer.emit('triggerInner', {from: 'outer'});\r\n      outer.send('this msg from outer');\r\n  }, 500);\r\n \r\n // 内部窗口代码，假设内部窗口的URI为 http://localhost:3000\r\n   var inner = x.frame(window.parent);\r\n  inner.on('triggerInner', function (data) {\r\n      console.log('[LOG triggerInner] type:frames,data: ' + JSON.stringify(data))\r\n  });\r\n  //⚠注意：Message事件为内置事件，接受对方通过send方法发过来的消息对象必须通过注册该事件才可收到。\r\n  inner.on('Message',function(data){\r\n      console.log('[LOG Message Inner] type:frames,data: ' + JSON.stringify(data))\r\n  });\r\n\r\n  setTimeout(function(){\r\n      inner.emit('triggerOuter', {from: 'inner'});\r\n      inner.send('this msg from inner');\r\n  },1000);\r\n \r\n```\r\n\r\n`注意:`<br/>\r\n1: 此方法仅用于不同域名iframe之间交互使用，不会与服务器进行任何交互。.<br/>\r\n\r\n#### frameHandle对象\r\nframeHandle对象为x.frame(param...); 方法的返回值。操作ifarme之间的消息通讯必须通过此对象才可实现。<br/>\r\n*frameHandle对象只有4个实例方法，没有静态方法。*\r\n\r\n###### on(eventName, callback);\r\n注册回调事件，以供目标window对象调用。\r\n\r\n`参数列表:`\r\n>+ @param eventName      {string} 方法名称\r\n>+ @param callback     {function} 回调函数\r\n\r\n###### emit(eventName, param);\r\n触发对方的回调事件。\r\n\r\n`参数列表:`\r\n>+ @param eventName      {string} 需要触发的方法名称\r\n>+ @param param     {object|string} 参数\r\n\r\n###### send(message);\r\n向对方发送消息。对方必须通过on方法注册`Message`事件才可收到通过此方法发送的消息。\r\n\r\n`参数列表:`\r\n>+ @param message      {string} 消息内容\r\n\r\n###### fire(eventName, [param1,param2...]]);\r\n触发本窗口注册的事件。\r\n\r\n`参数列表:`\r\n>+ @param eventName      {string} 方法名称\r\n>+ @param [param1,param2...]]     {array} 参数列表\r\n\r\n## 疑问?\r\n\r\n如果您有任何疑问，请随时提出通过 [New Issue](https://github.com/YataoZhang/xMan/issues/new).\r\n\r\n## License\r\n\r\nxMan.js在MIT的条款下提供 [MIT License](https://github.com/YataoZhang/xMan/blob/master/LICENSE).\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}